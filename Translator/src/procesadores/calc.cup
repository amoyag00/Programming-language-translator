package procesadores;
import java_cup.runtime.*;
import java.io.*;
import java.util.Stack;
import java.util.List;

parser code {:
Yylex analizadorLexico;

public static void main(String[] argv){
	if (argv.length == 0) {
		      System.out.println("Uso : java Parser  <inputfile)>");
		    }
	else{
	try {
		TablaSimbolos tabla = new TablaSimbolos();
		java.io.FileInputStream stream = new java.io.FileInputStream(argv[0]);
	    java.io.Reader reader = new java.io.InputStreamReader(stream);
		Yylex analizadorLexico= new Yylex(reader,tabla);
		Parser parserObj = new Parser();
		parserObj.analizadorLexico=analizadorLexico;
		parserObj.setScanner(parserObj.analizadorLexico);
		parserObj.parse();
		}
		catch(Exception x) {
		x.printStackTrace();
		System.out.println("Error fatal.");
		}
	}
}

public void error_sintactico(Symbol current_token){
  report_error("Error de sintaxis: linea "+analizadorLexico.linea()+" columna "+analizadorLexico.columna(),current_token);
  
}

:};


/*Inicializacion del analizador lexico si procede*/
//init with {: s.init(); :};
/*Siguiente token al lexico*/
//scan with {: return this.getScanner().next_token(); :};

/*Terminales tokens que puede devolver el lexico*/
terminal END_INSTR, STRUCT, END_STRUCT, INIT_BLOCK, END_BLOCK, OPEN_PAR, CLOSE_PAR, OPEN_BRACKETS, CLOSE_BRACKETS, FUNCTION, INT, REAL, CHAR, STRING, BOOL, ASSIGN, LESS, GREATER, EQUAL, NOT_EQUAL, LESS_EQUAL, GREATER_EQUAL, AND, OR, PLUS, MINUS, DIV, MOD, MULT, POW, WHILE, IF, ELSE, COMMA, POINT, TRUE, FALSE, RETURN, READ, PRINT/*, ARRAY*/; 



/*Terminales con atributo*/
terminal Integer NUM_INT;
terminal Float NUM_REAL;
terminal Character CHAR_LITERAL;
terminal String STRING_LITERAL;
terminal String ID;

/* No terminales sin atributo*/
non terminal program, declarations , structs, struct, functions, function, instructions, loop, if, else, conditions, condition, validate_operator, logic_operator, expression, assign, operator, create_struct, print;

/* No terminales con atributo*/
/*non terminal  Integer expr, asignacion;*/
non terminal Stack   list, variables, structvars, params,arg_list;
non terminal Simbolo literal, numeric_expr, id, returntype, index, type, array;

/*Precedencias*/
precedence left PLUS,MINUS;
precedence left MULT,DIV,MOD;
precedence right POW;

/*Gramatica*/

program ::= declarations END_STRUCT functions {:  :};

declarations ::= variables structs {:  :};

variables ::= type:sim list:l END_INSTR variables {:
	RESULT = l;
	TablaSimbolos tabla = this.parser.analizadorLexico.getTabla();
	for (int i=0 ;i<l.size();i++){
		Simbolo simbolo = (Simbolo) l.get(i);
		
		String nombre =simbolo.getNombre();
		Simbolo aux= tabla.buscar(nombre);
		if(aux == null){
			//aux = new Simbolo(nombre, null);
			tabla.insertar(simbolo);
			simbolo.setTipo(sim.getTipo());
		}else{
			System.out.println("Error, la variable "+ aux.nombre+" ya se ha declarado ");
			 //TODO decir linea y columna
		}
		
	}
	
	System.out.println("Las variables "+l.toString()+ " son del tipo "+sim.getTipo());  
:} | {: :};

list ::= ID:s COMMA list:l {: 

			 RESULT =l;
			 Simbolo sim = new Simbolo();
			 sim.setNombre(s);
			 RESULT.push(sim); 
			 
		:} | ID:s {:
		
			 RESULT = new Stack();
			 Simbolo sim = new Simbolo();
			 sim.setNombre(s);
			 RESULT.push(sim);
			 
	 	:} | array:sim COMMA list:l{:
	 	
	 		RESULT = l;
			RESULT.push(sim);
			
	 	:} | array:sim {: 
	 	
	 		RESULT = new Stack();
	 		RESULT.push(sim);
	 		
	 	:};

type ::= INT {:

		Simbolo sim = new Simbolo();
		sim.setTipo("INT");
		RESULT = sim; 
		
	:} | REAL {:
	
		Simbolo sim = new Simbolo();
		sim.setTipo("REAL");
		RESULT = sim; 
		
	:} | CHAR {: 
	
		Simbolo sim = new Simbolo();
		sim.setTipo("CHAR");
		RESULT = sim;
		
	:} | STRING {:
	
		Simbolo sim = new Simbolo();
		sim.setTipo("STRING");
		RESULT = sim; 
		 
	:} | BOOL {:
	
		Simbolo sim = new Simbolo();
		sim.setTipo("BOOL");
		RESULT = sim;
		
	:};

returntype ::= type:sim {: 

	RESULT = sim; 
	
:};
 
array ::= ID:s index:sim{: 
	sim.setNombre(s);
	RESULT=sim;
:};


structs ::= struct END_INSTR structs{: :}  | {: :};

struct ::= STRUCT ID:s INIT_BLOCK structvars:t END_BLOCK {: 
	TablaSimbolos tabla = this.parser.analizadorLexico.getTabla();
	
	if(tabla.buscarStructDef(s)==null){
		
		StructDefinition def = new StructDefinition(s);
		def.addAttributes(t);
		tabla.addStructDef(def);
	
	}else{
		System.out.println("Error, la struct "+ s+" ya se ha definido ");
	}
	
	
:};

structvars ::= type:sim ID:nombre END_INSTR structvars:stack {:
	RESULT= stack;
	//TODO cuidado aqui
	sim.setNombre(nombre);
	RESULT.push(sim);

:} | type:sim ID:nombre END_INSTR {:

	RESULT=new Stack();
	//TODO cuidado aqui
	sim.setNombre(nombre);
	RESULT.push(sim);
	
:} | type:sim array:simbolo END_INSTR structvars:stack {:

	RESULT=stack;
	//TODO cuidado aqui
	simbolo.setTipo(sim.getTipo());
	RESULT.push(simbolo);

:} | type:sim array:simbolo END_INSTR{:

	RESULT=new Stack();
	//TODO cuidado aqui
	simbolo.setTipo(sim.getTipo());
	RESULT.push(simbolo);

:};


functions ::= function functions {: :} | function {: :};

function ::= FUNCTION returntype:sim1 ID:s OPEN_PAR params:l CLOSE_PAR INIT_BLOCK {:
	TablaSimbolos tabla = this.parser.analizadorLexico.getTabla();
 	if(tabla.buscarGlobal(s)==null){
 		Simbolo function = new Simbolo(s, null);
		function.setTipo("FUNCTION");
		for (int i=l.size()-1 ;i>-1;i--){
		Simbolo sim = (Simbolo) l.get(i);
			function.addParamType( sim.getTipo());
		}
		tabla.insertar(function);
		function.setTipo("FUNCTION");
		function.setTipoRetorno(sim1.getTipo());
 		tabla.set();
 	}else{
 		System.out.println("Error, ya se ha declarado la función "+ s);
 	}
:}variables instructions RETURN id:sim2 END_INSTR END_BLOCK {:
			TablaSimbolos tabla = this.parser.analizadorLexico.getTabla();
			if(!tabla.isAssignable(sim1.getTipo(), sim2.getTipo())){
				System.out.println("Error, la función "+s+" debe de retornar un valor "+
				"de tipo "+sim1.getTipo()+" y está retornando un valor de tipo "+sim2.getTipo());
			}
		
:};

params ::= type:sim ID COMMA params:l {:
				RESULT = l;
				RESULT.push(sim); 
		   :} | type:sim ID {:
		   		RESULT = new Stack();
		   		RESULT.push(sim);
		   :} | {: 
		   		RESULT = new Stack();
		   :};

instructions ::= expression END_INSTR instructions {: :} | expression END_INSTR {: :};

loop ::= WHILE OPEN_PAR conditions CLOSE_PAR INIT_BLOCK instructions END_BLOCK {: :};

if ::= IF OPEN_PAR conditions CLOSE_PAR INIT_BLOCK instructions END_BLOCK else {: :};

else ::= ELSE INIT_BLOCK instructions END_BLOCK {: :} | {: :};

conditions ::= condition {: :} | condition logic_operator conditions {: :};

condition ::= id validate_operator id {: :};

id ::= ID:s {: 
			TablaSimbolos tabla = this.parser.analizadorLexico.getTabla();
			Simbolo simbolo=tabla.buscarGlobal(s);
			
			if(simbolo==null){
				System.out.println("Error, la variable "+s+" no se ha declarado");
			}else{
				RESULT= simbolo;
			}
			
		:} | literal:sim {:
			
			RESULT = sim;
		
		:} | ID:s POINT ID:att {:
		
			TablaSimbolos tabla = this.parser.analizadorLexico.getTabla();
			Simbolo simbolo=tabla.buscarGlobal(s);
			
			if(simbolo==null){
				System.out.println("Error, la variable "+s+" no se ha declarado");
			}else{
				StructDefinition def =simbolo.getStructInstance().getStructDef();
				String attType= def.getTipoOf(att);
				if(attType==null){
					System.out.println("La variable de tipo struct "+s+
					" no tiene ningún atributo "+att);
				}else{
					Simbolo sim = new Simbolo();
					sim.setTipo(attType);
					RESULT= sim;
				}
				
			}	
			
			
		:} | ID:s OPEN_PAR arg_list:tipos CLOSE_PAR {:
				TablaSimbolos tabla = this.parser.analizadorLexico.getTabla();
				Simbolo function=tabla.buscarGlobal(s);
				
	 			if(function==null){
					System.out.println("Error, la función "+s+" no existe");	
				}else if(!function.getTipo().equals("FUNCTION")){
					System.out.println("Error, "+s+" no es una función");
				}else{
					List<String> expectedTipos = function.getParamTypes();
					if(expectedTipos.size()!=tipos.size()){
						System.out.println("Error, la función "+s+" espera "+expectedTipos.size()+
						" parámetros");
					}
					for(int i=tipos.size()-1; i>-1;i--){
						if(!expectedTipos.get(tipos.size()-1-i).equals(tipos.get(i))){
							System.out.println("Error, el parametro "+(tipos.size()-1-i)+
							"de la funcion "+ s+" ha de ser de tipo "+
							expectedTipos.get(tipos.size()-i));
						}
					}
				}
				Simbolo sim = new Simbolo();
				sim.setTipo(function.getTipoRetorno());
				RESULT = sim;
				
	   :} |ID:s index:sim {: 
	   		TablaSimbolos tabla = this.parser.analizadorLexico.getTabla();
			Simbolo simbolo = tabla.buscarGlobal(s);
			
 			if(simbolo==null){
				System.out.println("Error, el array "+s+" no existe");	
			}else{
				sim.setTipo(simbolo.getTipo());
				sim.setDimension(simbolo.getDimension() - sim.getDimension());
				RESULT = sim;
				
			
			}
	   :};
	   
index ::= OPEN_BRACKETS NUM_INT CLOSE_BRACKETS index:sim {: 

	sim.increaseDim();
	RESULT = sim;

:}| OPEN_BRACKETS NUM_INT CLOSE_BRACKETS	{: 
	
	Simbolo simbolo = new Simbolo();
	simbolo.setDimension(1);
	RESULT = simbolo;
	
:};   

validate_operator ::= EQUAL {: :} | NOT_EQUAL {: :} | LESS_EQUAL {: :} | GREATER_EQUAL {: :} |
				 	  LESS {: :} |  GREATER {: :};

logic_operator ::= AND {: :} | OR {: :};

expression ::= assign {: :} | 
				ID:s OPEN_PAR arg_list:tipos CLOSE_PAR  {:
				
					TablaSimbolos tabla = this.parser.analizadorLexico.getTabla();
					Simbolo function=tabla.buscarGlobal(s);
					
		 			if(function==null){
						System.out.println("Error, la función "+s+" no existe");	
					}else if(!function.getTipo().equals("FUNCTION")){
						System.out.println("Error, "+s+" no es una función");
					}else{
						List<String> expectedTipos = function.getParamTypes();
						if(expectedTipos.size()!=tipos.size()){
							System.out.println("Error, la función "+s+" espera "+expectedTipos.size()+
							" parámetros");
						}
						for(int i=tipos.size()-1; i>-1;i--){
							if(!expectedTipos.get(tipos.size()-1-i).equals(tipos.get(i))){
								System.out.println("Error, el parametro "+(tipos.size()-i)+
								" de la funcion "+ s+" ha de ser de tipo "+
								expectedTipos.get(tipos.size()-1-i));
							}
						}
					}
				:} | create_struct  {: :} | 
 			   READ OPEN_PAR type COMMA id CLOSE_PAR {: :} |
 			   PRINT OPEN_PAR print CLOSE_PAR {: :} |
 			   loop {: :} | if {: :};
 
assign ::= ID:s ASSIGN numeric_expr:sim {: 
				
				TablaSimbolos tabla = this.parser.analizadorLexico.getTabla();
					Simbolo simbolo=tabla.buscarGlobal(s);
				
				if(simbolo==null){
					System.out.println("Error, la variable "+s+" no existe");
				}else{
					String expectedTipo = simbolo.getTipo();
					if(!tabla.isAssignable(expectedTipo,sim.getTipo())){
						System.out.println("Error, no se puede asignar una variable de tipo "+
						sim.getTipo()+" a una variable de tipo "+expectedTipo);
					}else if(simbolo.getDimension()!=sim.getDimension()){
						System.out.println("Error, no se puede asignar una variable de dimensión "+
						sim.getDimension()+" a una variable de dimensión "+simbolo.getDimension());
					}
				}
				
		   :} | ID:s index ASSIGN numeric_expr:sim {: 
		   		
		   		TablaSimbolos tabla = this.parser.analizadorLexico.getTabla();
					Simbolo simbolo=tabla.buscarGlobal(s);
				
				if(simbolo==null){
					System.out.println("Error, la variable "+s+" no existe");
				}else{
					String expectedTipo = simbolo.getTipo();
					if(!tabla.isAssignable(expectedTipo,sim.getTipo())){
						System.out.println("Error, no se ha puede asignar una variable de tipo "+
						sim.getTipo()+" a una variable de tipo "+expectedTipo);
					}
				}
				
		   :} | ID:sStruct POINT ID:attName ASSIGN numeric_expr:sim {: 
		   
		   		TablaSimbolos tabla = this.parser.analizadorLexico.getTabla();
		   		Simbolo struct = tabla.buscarGlobal(sStruct);
		   		if(struct==null){
		   			System.out.println("Error, no ha creado ninguna struct de nombre "+sStruct);
		   		}else{
		   			StructDefinition def = struct.getStructInstance().getStructDef();
		   			String attTipo = def.getTipoOf(attName);
		   			if(attTipo==null){
		   				System.out.println("La struct "+sStruct+" no tiene ningún atributo de nombre "+
		   				attName);
		   			}else if(struct.getDimension()!=sim.getDimension()){
						System.out.println("Error, no se puede asignar una variable de dimensión "+
						sim.getDimension()+" a un atributo de una struct de dimensión "+struct.getDimension());
					}else if(tabla.isAssignable(attTipo, sim.getTipo())){
						RESULT = attTipo;
		   			}else{
		   				System.out.println("Error, no se puede asignar una variable de tipo "+
		   				sim.getTipo()+" a un atributo de una struct de tipo "+attTipo);
		   			}
		   			
		   		}
		   		
		   :};

numeric_expr ::= numeric_expr:sim1 operator id:sim2 {:
					
					TablaSimbolos tabla = this.parser.analizadorLexico.getTabla();
					
					if( !tabla.isNumeric(sim1.getTipo()) || !tabla.isNumeric(sim2.getTipo()) ){
						System.out.println("Error, las operaciones matemáticas han de ser"+
						" entre tipos REAL o INT. No se puede operar el tipo "+sim1.getTipo()+
						" con el tipo "+sim2.getTipo());	
					}else{
					
						if(sim1.getTipo().equals("REAL") || sim2.getTipo().equals("REAL") ){
							Simbolo sim = new Simbolo();
							sim.setTipo("REAL");
							RESULT= sim;
						}else{
							Simbolo sim = new Simbolo();
							sim.setTipo("INT");
							RESULT= sim;
						}
					}
				 :} | id:sim {: 
				 
				 	RESULT=sim;
				 	
				 :} | MINUS id:sim {:
				 
				 	RESULT= sim;
				 	
				 :} | OPEN_PAR numeric_expr:sim CLOSE_PAR  {: 
				 
				 	RESULT= sim;
				 	
				 :};

operator ::=  PLUS  {: :} | MINUS{: :}| POW{: :}| MOD{: :}| DIV {: :}| MULT {: :};

create_struct ::=  STRUCT ID:structDef ID:s {: 
				
					TablaSimbolos tabla = this.parser.analizadorLexico.getTabla();
					StructDefinition def = tabla.buscarStructDef(structDef);
					
					if(def==null){
						System.out.println("Error, no se ha definido un struct de nombre "+structDef);
					}else{
						Simbolo simbolo = new Simbolo(s, null);
						simbolo.createStructInstance(def);
						simbolo.setTipo("STRUCT");
						tabla.insertar(simbolo);
					}
				:};

print ::=  id COMMA print  {: :} | id {: :};

arg_list ::= ID:s COMMA arg_list:stack  {:
	
		RESULT= stack; 
		TablaSimbolos tabla = this.parser.analizadorLexico.getTabla();
		Simbolo simbolo=tabla.buscarGlobal(s);
				
	 	if(simbolo==null){
			System.out.println("Error, la variable "+s+" no se ha declarado");	
		}else{
			RESULT.push(simbolo.getTipo());		
		}
	
	:} | literal:l COMMA arg_list:stack {:

		RESULT= stack; 
		RESULT.push(l);		
		
		
	:} | ID:s {: 
	
		RESULT = new Stack();
		TablaSimbolos tabla = this.parser.analizadorLexico.getTabla();
		Simbolo simbolo=tabla.buscarGlobal(s);
				
	 	if(simbolo==null){
			System.out.println("Error, la variable "+s+" no se ha declarado");	
		}else{
			RESULT.push(simbolo.getTipo());		
		}
	 
	:} | literal:l {:
	 
		RESULT = new Stack();
		RESULT.push(l);
	:}| {: 
		RESULT = new Stack();
	:};

literal ::= NUM_INT {: 

	Simbolo sim = new Simbolo();
	sim.setTipo("INT");
	RESULT=sim; 
	
:} | NUM_REAL {: 

	Simbolo sim = new Simbolo();
	sim.setTipo("REAL");
	RESULT=sim; 
	
:} | CHAR_LITERAL {: 

	Simbolo sim = new Simbolo();
	sim.setTipo("CHAR");
	RESULT=sim; 
	
:} | STRING_LITERAL {:
 
	Simbolo sim = new Simbolo();
	sim.setTipo("STRING");
	RESULT=sim;
	
:} | TRUE{: 

	Simbolo sim = new Simbolo();
	sim.setTipo("BOOL");
	RESULT=sim;
	 
:} | FALSE{: 

	Simbolo sim = new Simbolo();
	sim.setTipo("BOOL");
	RESULT=sim; 
	
:};
